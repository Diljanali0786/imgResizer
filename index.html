<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Exact KB Image Resizer</title>

  <!-- Cropper.js CDN -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.css" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.js"></script>

  <style>
    body { font-family: sans-serif; text-align: center; padding: 20px; }
    #preview { max-width: 100%; margin-top: 20px; }
    #downloadBtn { background-color: blue; color: white; padding: 10px 20px; border: none; cursor: pointer; margin-top: 20px; }
    #downloadBtn.green { background-color: green; }
    input, select { margin: 5px; padding: 5px; }
  </style>
</head>
<body>
  <h2>Exact KB Image Resizer</h2>

  <input type="file" id="fileInput" accept="image/*"><br>
  <input type="number" id="widthInput" placeholder="Width">
  <input type="number" id="heightInput" placeholder="Height">
  <select id="unitSelect">
    <option value="px">px</option>
    <option value="cm">cm</option>
  </select><br>
  <input type="number" id="targetKB" placeholder="Target KB"><br>

  <div>
    <img id="preview" style="max-width:300px; display:none;">
  </div>

  <button id="downloadBtn">Download Image</button>

  <script>
    const fileInput = document.getElementById('fileInput');
    const preview = document.getElementById('preview');
    const widthInput = document.getElementById('widthInput');
    const heightInput = document.getElementById('heightInput');
    const unitSelect = document.getElementById('unitSelect');
    const targetKB = document.getElementById('targetKB');
    const downloadBtn = document.getElementById('downloadBtn');

    let cropper;

    function cmToPx(cm) {
      return (cm / 2.54) * 96;
    }

    fileInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = () => {
        preview.src = reader.result;
        preview.style.display = 'block';

        if (cropper) cropper.destroy();

        cropper = new Cropper(preview, {
          viewMode: 1,
          movable: true,
          zoomable: true,
          scalable: false,
          cropBoxResizable: true,
        });

        setTimeout(updateCropBox, 500);
      };
      reader.readAsDataURL(file);
    });

    unitSelect.addEventListener('change', updateCropBox);

    function updateCropBox() {
      if (!cropper) return;

      let width = parseFloat(widthInput.value);
      let height = parseFloat(heightInput.value);
      let unit = unitSelect.value;

      if (!width || !height) return;

      if (unit === 'cm') {
        width = cmToPx(width);
        height = cmToPx(height);
      }

      cropper.setCropBoxData({
        width: width,
        height: height
      });
    }

    widthInput.addEventListener('input', updateCropBox);
    heightInput.addEventListener('input', updateCropBox);

    downloadBtn.addEventListener('click', () => {
      if (!cropper) return alert('Please upload and crop an image first.');

      let width = parseFloat(widthInput.value);
      let height = parseFloat(heightInput.value);
      let unit = unitSelect.value;
      let targetSize = parseInt(targetKB.value) * 1024;

      if (!width || !height || !targetSize) {
        alert('Please enter width, height, and target KB before downloading.');
        return;
      }

      if (unit === 'cm') {
        width = cmToPx(width);
        height = cmToPx(height);
      }

      async function binarySearchExactCompress() {
        const canvas = cropper.getCroppedCanvas({ width: width, height: height });

        let minQ = 0.1;
        let maxQ = 1.0;
        let bestBlob = null;
        let bestDiff = Infinity;
        let attempts = 0;

        while (minQ <= maxQ && attempts < 20) {
          let midQ = (minQ + maxQ) / 2;

          const blob = await new Promise(resolve => {
            canvas.toBlob(resolve, 'image/jpeg', midQ);
          });

          const size = blob.size;
          const diff = Math.abs(size - targetSize);

          if (diff < bestDiff) {
            bestBlob = blob;
            bestDiff = diff;
          }

          if (size > targetSize) {
            maxQ = midQ - 0.005;
          } else if (size < targetSize) {
            minQ = midQ + 0.005;
          } else {
            bestBlob = blob;
            break;
          }

          attempts++;
        }

        if (bestBlob) {
          const finalSizeKB = (bestBlob.size / 1024).toFixed(2);
          console.log(`Final Size: ${finalSizeKB} KB`);

          const url = URL.createObjectURL(bestBlob);
          const a = document.createElement('a');
          a.href = url;
          a.download = 'resized-image.jpg';
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          downloadBtn.classList.add('green');
        } else {
          alert("Couldn't reach target size within quality limits.");
        }
      }

      binarySearchExactCompress();
    });
  </script>
</body>
</html>
