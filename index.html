<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Exact KB Resizer Final</title>

  <link href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.css" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.js"></script>

  <style>
    body { font-family: sans-serif; text-align: center; padding: 20px; }
    #preview { max-width: 100%; margin-top: 20px; }
    #downloadBtn { background-color: blue; color: white; padding: 10px 20px; border: none; cursor: pointer; margin-top: 20px; }
    #downloadBtn.green { background-color: green; }
    input, select { margin: 5px; padding: 5px; }
  </style>
</head>
<body>
  <h2>Exact KB Resizer Final</h2>

  <input type="file" id="fileInput" accept="image/*"><br>
  <input type="number" id="widthInput" placeholder="Width">
  <input type="number" id="heightInput" placeholder="Height">
  <select id="unitSelect">
    <option value="px">px</option>
    <option value="cm">cm</option>
  </select><br>
  <input type="number" id="targetKB" placeholder="Target KB"><br>

  <div>
    <img id="preview" style="max-width:300px; display:none;">
  </div>

  <button id="downloadBtn">Download Image</button>

  <script>
    const fileInput = document.getElementById('fileInput');
    const preview = document.getElementById('preview');
    const widthInput = document.getElementById('widthInput');
    const heightInput = document.getElementById('heightInput');
    const unitSelect = document.getElementById('unitSelect');
    const targetKB = document.getElementById('targetKB');
    const downloadBtn = document.getElementById('downloadBtn');

    let cropper;

    function cmToPx(cm) {
      return (cm / 2.54) * 96;
    }

    fileInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = () => {
        preview.src = reader.result;
        preview.style.display = 'block';

        if (cropper) cropper.destroy();

        cropper = new Cropper(preview, {
          viewMode: 1,
          movable: true,
          zoomable: true,
          scalable: false,
          cropBoxResizable: true,
        });

        setTimeout(updateCropBox, 500);
      };
      reader.readAsDataURL(file);
    });

    unitSelect.addEventListener('change', updateCropBox);

    function updateCropBox() {
      if (!cropper) return;

      let width = parseFloat(widthInput.value);
      let height = parseFloat(heightInput.value);
      let unit = unitSelect.value;

      if (!width || !height) return;

      if (unit === 'cm') {
        width = cmToPx(width);
        height = cmToPx(height);
      }

      cropper.setCropBoxData({
        width: width,
        height: height
      });
    }

    widthInput.addEventListener('input', updateCropBox);
    heightInput.addEventListener('input', updateCropBox);

    downloadBtn.addEventListener('click', () => {
      if (!cropper) return alert('Please upload and crop an image first.');

      let width = parseFloat(widthInput.value);
      let height = parseFloat(heightInput.value);
      let unit = unitSelect.value;
      let targetSize = parseInt(targetKB.value) * 1024;

      if (!width || !height || !targetSize) {
        alert('Please enter width, height, and target KB before downloading.');
        return;
      }

      if (unit === 'cm') {
        width = cmToPx(width);
        height = cmToPx(height);
      }

      async function resizeAndCompress() {
        let tempWidth = width;
        let tempHeight = height;
        let minQuality = 0.1;
        let maxQuality = 1.0;

        while (true) {
          const canvas = cropper.getCroppedCanvas({ width: tempWidth, height: tempHeight });

          let bestBlob = null;
          let bestDiff = Infinity;
          let attempts = 0;
          let lowQ = minQuality, highQ = maxQuality;

          // Binary search for best quality at current dimensions
          while (lowQ <= highQ && attempts < 20) {
            let midQ = (lowQ + highQ) / 2;

            const blob = await new Promise(resolve => {
              canvas.toBlob(resolve, 'image/jpeg', midQ);
            });

            const size = blob.size;
            const diff = Math.abs(size - targetSize);

            if (diff < bestDiff) {
              bestBlob = blob;
              bestDiff = diff;
            }

            if (size > targetSize) {
              highQ = midQ - 0.01;
            } else if (size < targetSize) {
              lowQ = midQ + 0.01;
            } else {
              bestBlob = blob;
              break;
            }
            attempts++;
          }

          if (bestBlob && bestBlob.size <= targetSize + 2000) { // Allow 2KB margin
            const url = URL.createObjectURL(bestBlob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'resized-image.jpg';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            downloadBtn.classList.add('green');
            console.log(`Final size: ${(bestBlob.size / 1024).toFixed(2)} KB`);
            break;
          }

          // Reduce dimensions by 10% if cannot reach target
          tempWidth *= 0.9;
          tempHeight *= 0.9;

          if (tempWidth < 50 || tempHeight < 50) {
            alert("Couldn't reach target size. Image became too small.");
            break;
          }
        }
      }

      resizeAndCompress();
    });
  </script>
</body>
</html>
